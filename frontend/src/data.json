{
  "navbar": {
    "sectionOne": [
      {
        "title": "Home",
        "icon": "/images/Home.png",
        "link": "/"
      },
      {
        "title": "Search",
        "icon": "/images/Search.png",
        "link": "/search"
      }
    ],
    "Quick Browse": [
      {
        "title": "Projects",
        "icon": "/images/Projects.png",
        "link": "/projects"
      },
      {
        "title": "About Me",
        "icon": "/images/ProfileButtonImage.jpg",
        "link": "/about"
      },
      {
        "title": "Contact Me",
        "icon": "/images/ContactMe.png",
        "link": "/contact"
      },
      {
        "title": "The Frog Blog",
        "icon": "/images/frogblog.jpg",
        "link": "/blog"
      }
    ],
    "My Links": [
      {
        "title": "LinkedIn",
        "icon": "/images/LinkedIn.png",
        "link": "https://www.linkedin.com/in/tylerbe/"
      },
      {
        "title": "Github",
        "icon": "/images/Github.png",
        "link": "https://www.github.com/TylerBeach"
      },
      {
        "title": "Email",
        "icon": "/images/Email.png",
        "link": "mailto:tabeach@ualberta.ca"
  
      },
      {
        "title": "Resume",
        "icon": "/images/Resume.png",
        "link": "/resume"
      }
    ],
    "Spotify Links": [
      {
        "title": "My Spotify",
        "icon": "/images/Spotify.png",
        "link": "https://open.spotify.com/user/impoona"
      },
      {
        "title": "EDM",
        "icon": "/images/House.png",
        "link": "https://open.spotify.com/playlist/6AgKp1uhxAubwcz4hgvFpN?si=c8d62009bd2d4ee6"
      },
      {
        "title": "Lofi",
        "icon": "/images/Lofi.png",
        "link": "https://open.spotify.com/playlist/4w9CwgUyxc7bSH8S24draO?si=dbd4a57917834a0b"
      },
      {
        "title": "Chilling",
        "icon": "/images/Chilling.png",
        "link": "https://open.spotify.com/playlist/5qiAWYzhjGo7Sh1BrLYMxy?si=f53a2a08498f4934"
      }
    ]
}, 
  "projects": [
    {
      "id": "GazpreaCompiler",
      "title": "Gazprea Compiler",
      "cardDescription": "A Compiler for the Gazprea programming language built using C++, ANTLR4, MLIR and LLVM.",
      "paragraphData": [
        {
          "paragraphTitle": "CMPUT 415 Compilers",
          "paragraphContent": "This project was created as part of CMPUT 415 - Compilers at the University of Alberta. The course focuses on the design and implementation of compilers, covering topics such as lexical analysis, parsing, semantic analysis, optimization, and code generation. Over the course of the semester we worked together to create a fully functioning compiler that met all the specifications outlined in the Gazprea language documentation."
        },
        {
          "paragraphTitle": "Gazprea Language Overview",
          "paragraphContent": "Gazprea is a statically typed language derived from work at the IBM Hardware Acceleration Laboratory in Markham, ON. It emphasizes functional programming with controlled side effects. The language distinguishes pure functions (no side effects, usable in expressions) from procedures (allow side effects and I/O, called with <code>call</code>). By default, variables are immutable (<code>const</code>); mutability requires <code>var</code>. Gazprea supports <code>integers</code>, <code>chars</code>, <code>floats</code>, <code>booleans</code>, <code>arrays</code>, <code>matrices</code>, <code>vectors</code>, <code>strings</code>, <code>tuples</code>, and <code>structs</code>, with inferred-size declarations using <code>[*]</code>. Generator expressions like <code>[i in 1..10 | i * i]</code> enable declarative array construction, and the range operator <code>1..10</code> creates integer sequences. The type system includes type inference, type aliases, and automatic promotion. Built-in functions include <code>length()</code>, <code>shape()</code>, <code>reverse()</code>, and <code>format()</code>. Arrays are 1-indexed, and stream I/O uses <code>-></code> and <code><-</code> operators. These features make Gazprea suitable for mathematical and scientific computing while maintaining clear separation between pure computations and side effects."
        },
        {
          "paragraphTitle": "Things I Learned",
          "paragraphContent": "This was the first time I had worked on anything like this before. Throughout the project I constantly found myself learning new things about C++, MLIR, LLVM and in general how compilers worked. Our group really focused on having clean and maintainable code which was a great learning experience for me. Regular standups and pull request reviews helped keep the project on track and ensured that we were all on the same page. Our team also prioratized testing highly. In total our Compiler was about 31,000 lines of code. By the end of the term had about 32,000 lines of tests to ensure that our compiler met the specifications and worked as intended. Without these large amounts of tests I don't think we would have been able to complete the project successfully."
        },
        {
          "paragraphTitle": "Accomplishments",
          "paragraphContent": "Our group 'Gigagaz' ended up placing first overall when ranked among all the other groups in the CMPUT 415 Fall 2025 semester. We were able to be entirely feature complete having a very well rounded and robust compiler. Given this was an extremely complex project to undertake in a single semester I am very proud of what we were able to accomplish as a team. I cannot disclose implementation details due to university policies but you are able to see the entire specification of the Gazprea language and the requirements for the compiler <a href='https://cmput415.github.io/415-docs/gazprea/' style='text-decoration: underline;'>here</a>. Given the length of the specifications you can understand why this project was so complex and why we are so proud of what we were able to achieve."
        }
      ],
      "hostedLink": null,
      "imageURL": "/images/projectImages/GazpreaLogo.png",
      "bannerURL": "/images/projectImages/GazpreaBanner.png",
      "demoImages": [
        {"image": "/images/projectImages/GazpreaProgram1.png", "caption": "Gazprea Code Example" },
        {"image": "/images/projectImages/GazpreaProgram2.png", "caption": "Gazprea Code Example 2" },
        {"image": "/images/projectImages/GazpreaLLVM.png", "caption": "Generated LLVM Example" },
        {"image": "/images/projectImages/GazpreaParseTree.svg", "caption": "ANTLR4 Parse Tree (Open Image in new tab)" }
      ],
      "techStack": ["C++", "ANTLR4", "MLIR", "LLVM"],
      "date": "December 2025"

    },
    {
      "id": "GraphicsProgramming",
      "title": "Graphics Programming",
      "cardDescription": "A 3D Ascii Renderer and Voxel World Engine built from scratch in C++ using SDL2 and Raytracing techniques.",
      "paragraphData": [
        {
          "paragraphTitle": "Learning Graphics Programming",
          "paragraphContent": "This is a very impromptu sort of project not like anything I have ever done before. After working on MediMinutes for about 2 months I decided to take a deep dive into something I had no experience in and that ended up being graphics programming. My only experience before was CMPUT 206 - Digital Image Processing which taught me the basics of how images are represented in a computer and how to manipulate them but that was not overly useful for learning this project outside of the pixel work with shading. I started from scratch learning about raytracing techniques, 3D rendering concepts, and SDL2 for window management and rendering. One goal that I had for this project was to do the entire thing in Neovim which I did accomplish and I am very proud! I will go through each iteration of the project for you to see how I progressed and learned throughout the project."
        },
        {
          "paragraphTitle": "First Iteration - A Dream of Doom",
          "paragraphContent": "Every programmer has seen the 'I ported Doom onto my fridge or calculator' videos and that was sort of my inspiration for where I started. I wanted to create a simple ASCII renderer that could render a 3D world using raycasting techniques similar to Wolfenstein 3D and Doom. This is actually maybe the second iteration. I never recorded the very first which was me just playing with a single line of pixels and changing them based on distance. From there I took that 2D grid that I had and added the third dimension creating a simple 3D world that you could navigate around. It was very basic and had terrible performance but it was a start. I used very simple techniques like Ray Marching to determine the distance to the nearest wall and then rendered the pixel of ASCII characters based on that distance."
        },
        {
          "paragraphTitle": "Second Iteration - Improving the Renderer",
          "paragraphContent": "After completing the first iteration I wanted to improve a few things about it. Firstly I wanted to make it more efficient. The first iteration was terribly slow and every time you moved it felt like you blinked from frame to frame. I implemented a double buffering technique to help with this and it made a huge difference. Another big improvement was adding DDA ( Digital Differential Analyzer ) algorithm for raycasting instead of ray marching. This made the rendering so much faster as we could step through the grid much faster and then backtrack to find the exact distance to the wall allowing us to keep the performance high while still having accurate distance measurements. I also added more features such as better distance, higher resolution, floor + ceiling textures and better feeling movement. Overall this iteration felt pretty good and I think it was a solid improvement over the first."
        }, 
        {
          "paragraphTitle": "Third Iteration - SDL2 Port",
          "paragraphContent": "The second iteration was fun and all but I wanted to take it to the next level. I decided to port the entire thing over to SDL2 to allow for better graphics rendering and more control over the window. This was a huge undertaking as I had to rewrite a lot of the code to work with SDL2 but it was worth it. I was even able to add a minimap to help with navigation and even added direction indicators on it as well. The performance was also greatly improved and it felt much smoother to navigate around the world."
        },
        {
          "paragraphTitle": "Minecraft from Wish.com",
          "paragraphContent": "In my deep dive of learning graphics programming I came across a youtube video in my feed called 'I made Minecraft from scratch using C++!' and that really inspired me to try and create a voxel world like Minecraft. Previously I was taking a 2D grid and extruding it into 3D but now I wanted to create a true 3D world made up of voxels. I started by creating a simple voxel world with just a few blocks and then added more features such as distance shading and then created some noise generation to create a more interesting terrain much like Minecraft. This was a huge learning experience for me as I had to learn about 3D math, raytracing techniques, and how to optimize the rendering of a large number of voxels. Overall I am very proud of how far I have come with this project and I am excited to continue learning and improving my graphics programming skills."
        },
        {
          "paragraphTitle": "Minecraft but it kinda looks like Minecraft!?",
          "paragraphContent" : "Although this next iteration was not an insane addition I did add face shading. This made a huge difference in the look of the voxel world and made it feel much more like Minecraft. The distance shading was cool and all but adding face shading really brought the world to life. It was a simple addition but it made a huge difference in the overall look and feel of the project."
        },
        {
          "paragraphTitle": "Not bad kid",
          "paragraphContent": "This final iteration was something that I was truly proud of. I had created a voxel world that was able to cast shadows and had both distance and face shading. It was so cool to see a giant pillar of voxels casting a shadow on the ground and seeing the different faces of the voxels being shaded differently based on their orientation to the light source. This iteration included adding a light source that was moveable via the keyboard which allowed for some day and night effects. I added a more extreme noise generation to create taller mountains and deeper valleys. I think this was the best iteration yet and I am very proud of what I have accomplished with this project."
        },
        {
          "paragraphTitle": "What's Next?",
          "paragraphContent": "I am not entirely sure what is next for this project. I have learned a lot about graphics programming and I am excited to continue learning and improving my skills. I do want to add more features but most importantly I want to add even better performance optimizations. Right now the voxel world is still pretty slow and I want to make it faster. I also want to add more features such as textures, better lighting, and maybe even some basic physics. I want to be able to place different types of voxels and maybe even add some basic interactions with them. Overall I am very excited about the future of this project and I am looking forward to continuing to learn and improve my graphics programming skills. My current goal after graduation in December of 2025 is to create a full blown game engine using C++ and SDL2 so this project is just the beginning of my journey into graphics programming and I am enjoying every step of the way."
        }
      ],
      "link": null,
      "hostedLink": null,
      "imageURL": "/images/projectImages/3DRendererIcon.png",
      "bannerURL": "/images/projectImages/RendererBanner.png",
      "demoImages": [
        {"image": "/images/projectImages/ASCIIRenderer.mp4", "caption": "First Iteration Ascii Renderer" },
        {"image": "/images/projectImages/ASCIIRendererMap.png", "caption": "Example map for the ASCII Renderer" },
        {"image": "/images/projectImages/ASCIIRenderer2.mp4", "caption": "Second Iteration Ascii Renderer" },
        {"image": "/images/projectImages/3DRenderer.mp4", "caption": "SDL2 Port of Ascii Renderer" },
        {"image": "/images/projectImages/VoxelWorldNoShading.png", "caption": "Voxel World distance Shading" },
        {"image": "/images/projectImages/SimpleVoxelWorldShading.png", "caption": "Voxel World face Shading" },
        {"image": "/images/projectImages/VoxelWorldRender.png", "caption": "Voxel World with Light Source + Shadow Shading" }
      ],
      "techStack": ["C++", "SDL2", "Neovim"],
      "date": "August 2025"
    },
    {
      "id": "MediMinutes",
      "title": "MediMinutes",
      "cardDescription": "Medical learning application that allows users to learn and test their knowledge on various medical topics.",
      "paragraphData": [
        {
          "paragraphTitle": "Inspiration",
          "paragraphContent": "The original inspiration for MediMinutes occured during MediHacks 2024 Hackathon, where our team of five students from the University of Alberta set out to create a medical education application. We did a relatively good job given the time constraints but the MediMinutes you see today is a complete overhaul of the original project. I took the original idea and ran with it, creating a fully functional web application to empower users to learn about medical topics and test their knowledge."
        },
        {
          "paragraphTitle": "What it does",
          "paragraphContent": "We have several features such as daily crosswords, 'connections' where you aim to connect the symptoms to a diagnosis, a quiz feature where you can test your knowledge on a specific topic, and a flashcard feature where you can create your own decks or use the ones we have created. The goal of MediMinutes is to provide a platform for users to learn about medical topics in a fun and engaging way. We want to make medical education accessible to everyone, regardless of their background or experience level. We also want to create a community of learners who can share their knowledge and help each other grow."
        },
        {
          "paragraphTitle": "How it was built",
          "paragraphContent": "MediMinutes was built using Next.js, a React framework that allows for server-side rendering and static site generation. We used Tailwind CSS for styling, which allowed us to create a responsive and modern design. The backend is powered by AWS RDS, which provides a scalable and reliable database solution. NextAuth was used for authentication, allowing users to sign up and log in securely. Python was used for the web scraping and data processing, which allowed for the collection of data from Harvard Health, the FDA and the World Health Organization. Figma was used for the prototyping of the application, allowing us to create a user-friendly interface and design. The project was hosted on Vercel, which provides a fast and reliable hosting solution for Next.js applications."
        },
        {
          "paragraphTitle": "What's next for MediMinutes",
          "paragraphContent": "In the future, I plan to add more games for users to play and learn from. I also plan to add more features such as a forum where users can discuss medical topics and share their knowledge. I want to create a community of learners who can help each other grow and learn. I also plan to add more medical topics and resources to the application, making it a comprehensive platform for medical education. I hope to continue working on MediMinutes and make it the go-to platform for medical education."
        }
      ],
      "link": null,
      "hostedLink": "https://mediminutes.ca/",
      "imageURL": "/images/projectImages/quizTimeFrog10.png",
      "bannerURL": "/images/projectImages/MediMinBanner.png",
      "demoImages": [
        {"image": "/images/projectImages/MediMinutesHome.png", "caption": "Home Page"},
        {"image": "/images/projectImages/MediMinutesLogin.png", "caption": "Login"},
        {"image": "/images/projectImages/MediMinutesLearn.png", "caption": "Learn"},
        {"image": "/images/projectImages/MediMinutesLeaderboards.png", "caption": "Leaderboards"},
        {"image": "/images/projectImages/MediMinutesQuiz.png", "caption": "Quiz"},
        {"image": "/images/projectImages/MediMinutesCrossword.png", "caption": "Crossword"},
        {"image": "/images/projectImages/MediMinutesConnection.png", "caption": "Connections"}


      ],
      "techStack": ["Next.js", "Javascript", "Tailwind", "AWS", "Stripe", "Vercel", "Python"],
      "date": "May 2025"
    },
     {
      "id": "CourseHelperBot",
      "title": "Course Bot",
      "cardDescription": "University of Alberta Course API and Discord bot that helps students find courses and information.",  
      "paragraphData": [
        {
          "paragraphTitle": "What is it?",
          "paragraphContent": "Course Helper Bot is a University of Alberta Course API and Discord bot that helps students find courses and information about courses. This project was something I wanted to have for my own use because my friends would constantly mention a course they were taking and I would have no idea what the course was about. We would always talk within our discord server about courses and I thought it would be a great idea to make a bot that could help us find courses and information about courses quickly and easily."},
        {
          "paragraphTitle": "Current Features",
            "paragraphContent": "<table style='width: 100%; border-collapse: collapse;'><thead><tr style='background-color: #272727;'><th style='border: 1px solid #ddd; padding: 12px; text-align: left;'>Command</th><th style='border: 1px solid #ddd; padding: 12px; text-align: left;'>Description</th></tr></thead><tbody><tr><td style='border: 1px solid #ddd; padding: 12px;'>!course &lt;TERM&gt; &lt;DEPARTMENT&gt; &lt;COURSEID&gt;</td><td style='border: 1px solid #ddd; padding: 12px;'>Fetches information on a specific course.</td></tr><tr><td style='border: 1px solid #ddd; padding: 12px;'>!departments &lt;TERM&gt;</td><td style='border: 1px solid #ddd; padding: 12px;'>Lists all departments offering courses in the given term.</td></tr><tr><td style='border: 1px solid #ddd; padding: 12px;'>!help</td><td style='border: 1px solid #ddd; padding: 12px;'>Shows help message with all available commands.</td></tr><tr><td style='border: 1px solid #ddd; padding: 12px;'>!offered &lt;TERM&gt; &lt;DEPARTMENT&gt;</td><td style='border: 1px solid #ddd; padding: 12px;'>Gets all courses offered in that term in that department.</td></tr></tbody></table>"
        },
        {
          "paragraphTitle": "Hosting Infrastructure",
          "paragraphContent": "The API is created with Javascript and Express and it is hosted on Heroku. The Discord bot was created with Python and Discord.py and is self hosted on my own linux server. The bot uses the API to fetch course information and respond to user commands."
        },
        {
          "paragraphTitle": "How did I get the data?",
          "paragraphContent": "I created a web scraping script using Python and BeautifulSoup that gathered every single department and then iterated over each course offered in that department and the information about the course. It took about 20 minutes to run start to finish and then it gets stored inside the MongoDB database that the Heroku Express API accesses."
        },
        {
          "paragraphTitle": "Future Plans",
          "paragraphContent": "This was created as a quick looker upper for courses within discord purley for my convenience and my friends. It would be great if I could create a course scheduler in the future that could help students plan their courses for the semester. I also want to add more commands to the bot such as searching for courses by keywords and filtering courses by various criteria."
        }
      ],
      "link": null,
      "imageURL" : "/images/projectImages/CourseHelperBotIcon.png",
      "bannerURL" : "/images/projectImages/CourseHelperBotBanner.png",
      "demoImages": [
        {"image": "/images/projectImages/CourseHelperBot.png", "caption": "Course Helper Bot in action" }
      ],
      "techStack":[ "Javascript", "ExpressJS", "MongoDB", "Python", "DiscordPY", "Heroku", "Linux"],
      "date": "August 2024"
    },
        {
      "id": "Rizztagram",
      "title": "Rizztagram",
      "cardDescription": "CMPUT 404 Term Project - A social media web application clone of Instagram",  
      "paragraphData": [
        {
          "paragraphTitle": "What is it?",
          "paragraphContent": "Rizztagram is a social media web application clone of Instagram created in CMPUT 404 - Web Applications and Architecture at the University of Alberta. The project was created as a term project for the course and was developed by a team of six students. The goal of the project was to create a web application that mimics the functionality of Instagram, allowing users to create accounts, follow other users, post images, like and comment on posts, and view a feed of posts from users they follow."
        },
        {
          "paragraphTitle": "Distributed System Architecture",
          "paragraphContent": "Rizztagram was built using a distributed system allowing for the scalablity of nodes. We are very easily able to add another instance of the server and connect it via the Admin panel. Rizztagram was also able to connect to other groups within the course to allow for a widely distributed system. We were able to connect with two other groups within the course to allow for cross server communication and sharing of user data. This allowed for a more robust and scalable system, as users from different servers could interact with each other seamlessly."
        },
        {
          "paragraphTitle": "Software Engineering Practices",
          "paragraphContent": "Being a group project throughout the term, we implemented several software engineering practices to ensure the success of the project. We used Git for version control, allowing us to collaborate effectively and manage changes to the codebase. We also implemented Agile methodologies, holding regular stand-up meetings and sprint planning sessions to keep the project on track. Code reviews were conducted to ensure code quality and consistency across the team. Additionally, we used JIRA to track tasks and progress, ensuring that everyone was aware of their responsibilities and deadlines."
        }
      ],
      "hostedLink": "https://www.youtube.com/watch?v=d6U3Hyix7g8",
      "imageURL" : "/images/projectImages/RizztagramIcon.png",
      "bannerURL" : "/images/projectImages/RizztagramBanner.png",
      "demoImages": [
      ],
      "techStack":[ "Python", "Django", "SQL", "Heroku"],
      "date": "December 2024"
    },
    {
      "id": "AlgorithmTutor",
      "title": "Algorithm Tutor",
      "cardDescription": "An algorithm that allows users to visualize algorithms as they run step by step.",  
      "paragraphData": [
        {
          "paragraphTitle": "What is it?",
          "paragraphContent": "Algorithm Visualizer is a web application that allows users to visualize algorithms in action. Users can select from a variety of algorithms and see how they work step by step. The application was created as a personal project to help users learn about algorithms in a fun and interactive way. The goal of the project was to create a tool that would make learning about algorithms more accessible and engaging for users."
        },
        {
          "paragraphTitle": "What can it do?",
          "paragraphContent": "Algorithm Visualizer allows users to select from a variety of algorithms including sorting algorithms, searching algorithms, and array operatios. Users can see how the algorithms work step by step and learn about the different techniques used to solve problems. The application also includes a step by step code example for the algorithm being visualized. It also has many custom settings such as speed, array size, forward and backward buttons. Users can stop and start the visualization at any time to see how the algorithm works in real time." 
        },
        {
          "paragraphTitle": "How was it built?",
          "paragraphContent": "Algorithm Visualizer was built using Next.js, a React framework. The application uses Javascript and Tailwind CSS for styling. The algorithms are implemented in Javascript and are visualized using custom animations. The application is hosted on Vercel and is available to users on the web. The project was created as a personal project to help users learn about algorithms in a fun and interactive way. The goal of the project was to create a tool that would make learning about algorithms more accessible and engaging for users."
        },
        {
          "paragraphTitle": "Future Plans",
          "paragraphContent": "In the future, I plan to add more sorting algorithms and other data structures such as trees and stacks. I also plan to add more custom settings such as color themes and animations. I hope to continue working on the project and add more features over time."
        }
      ],
      "link": null,
      "hostedLink": "https://algorithm-tutor.vercel.app/",
     
      "imageURL" : "/images/projectImages/AlgorithmTutor.webp",
      "bannerURL" : "/images/projectImages/AlgorithmTutorBanner.png",
      "demoImages": [
        {"image": "/images/projectImages/AlgorithmVisualizer2.png", "caption": "Home Page" },
        {"image": "/images/projectImages/SortingExampleVideo3.gif", "caption": "Sorting Example" },
        {"image": "/images/projectImages/PathingExampleVideo2.gif", "caption": "Pathfinding Example" },
        {"image": "/images/projectImages/ArraysExampleVideo2.gif", "caption": "Array Operations" }
      ],
      "techStack":["Next.js", "Javascript", "Tailwind"],
      "date": "June 2024"
    },
    {
      "id": "StoryTeller",
      "title": "Story Teller",
      "cardDescription": "An AI powered story generator that creates unique stories with the click of a button.",  
      "paragraphData": [
        {
          "paragraphTitle": "What is it?",
          "paragraphContent": "StoryTeller is a web application that allows users to create stories. Leveraging the power of ai, users can generate unique stories with the click of a button. It was created during Hacked one of the biggest Hackathons in Alberta, Canada at the University of Alberta. Our five person team had a goal to implement as many AI tools as possible to create a unique and fun experience for users. "
        },
        {
          "paragraphTitle": "How does it work?",
          "paragraphContent": "StoryTeller uses openAI's generative text model to generate stories. Users can input a prompt and the model will generate a story based on the prompt. It is also capable of generating images that go along with your story using Stable Diffusion! Not to mention the read along feature that allows you to listen to your story using Eleven Labs Text to Speech!"
        }
      ],
      "link": "https://github.com/Active-Transport/story-time",
      "imageURL" : "/images/projectImages/StoryTellerIcon.png",
      "bannerURL" : "/images/projectImages/StoryTellerBanner.png",
      "demoImages": [
        {"image": "/images/projectImages/StoryTellerOne.png", "caption": "StoryTeller Home Page" },
        {"image": "/images/projectImages/StoryTellerTwo.png", "caption": "Story Prompt Input" },
        {"image": "/images/projectImages/StoryTellerThree.jpg", "caption": "Generated Story Example" }
      ],
      "techStack":["React", "Javascript", "CSS", "Python", "Flask"],
      "date": "January 2024"
    },
    {
      "id": "EventHorizon",
      "title": "Event Horizon",
      "cardDescription": "Android mobile app event manager that allows users to create and manage events",  
      "paragraphData": [
        {
          "paragraphTitle": "What is it?",
          "paragraphContent": "Event Horizon is a sophisticated Android mobile application designed to simplify the process of event management for users. The app allows users to create, manage, and participate in events with ease, making it a powerful tool for both personal and professional use. Whether it's a small gathering or a large-scale event, users can set up events, invite participants, and manage RSVPs all within the app. Event Horizon was developed as a final project for CMPUT 301 - Software Engineering at the University of Alberta. The project aimed to apply the principles and practices learned throughout the course in a real-world scenario, resulting in an application that not only meets course objectives but also provides practical value to users."
        },
        {
          "paragraphTitle": "How does it work?",
          "paragraphContent": "Event Horizon leverages Firebase as its backend to handle user authentication, store event data, and manage real-time updates. When a user creates an event, the details are securely stored in Firebase, ensuring that all participants have access to the most current information. The app allows users to invite friends through their contact list or by sharing event links, making it easy to gather participants. Additionally, Event Horizon integrates with Google Maps, providing users with a visual representation of event locations. This integration allows users to view the event's location directly within the app, receive directions, and even check in upon arrival. The combination of Firebase and Google Maps makes Event Horizon a robust and user-friendly solution for managing and attending events, ensuring users stay connected and informed."
        },
        {
          "paragraphTitle": "Software Engineering Design Patterns",
          "paragraphContent": "Event Horizon was meticulously designed using several key software engineering design patterns to ensure the application is efficient, scalable, and maintainable. The Model-View-Controller (MVC) pattern was employed to separate concerns within the app, ensuring that the data (Model), user interface (View), and application logic (Controller) are handled independently. This separation not only makes the app easier to manage and extend but also enhances its testability. The Adapter pattern was utilized to allow the app to interface seamlessly with various APIs, such as Firebase and Google Maps, by converting their data formats into a format the application can easily handle. Furthermore, the Singleton pattern was implemented for managing instances of Firebase, ensuring a single point of access to the database, which enhances performance and reduces the risk of data inconsistencies. These patterns were integral to the development of Event Horizon, allowing the team to apply theoretical knowledge in a practical, real-world project. They also mirror industry practices, providing the team with valuable experience in building scalable and maintainable software."
        },
        {
          "paragraphTitle": "User Experience and Interface Design",
          "paragraphContent": "Event Horizon was designed with a strong focus on user experience (UX) and interface design. The app's interface was created using Figma, ensuring a clean, intuitive, and accessible design. User flows were carefully planned to minimize friction, making it easy for users to create, manage, and join events. The design was iteratively tested and refined based on user feedback, ensuring that the app meets the needs of a diverse user base. By prioritizing UX, Event Horizon not only provides a functional tool but also an enjoyable and seamless experience for its users."
        }
        
      ],

      "link": "https://github.com/CMPUT301W24T09/fire-and-based",
      "imageURL" : "/images/projectImages/EventHorizonLogo.jpg",
      "bannerURL" : "/images/projectImages/EventHorizonBanner.webp",
      "demoImages": [
        {"image": "/images/projectImages/EventHorizon.png", "caption" : "Browse events tab" },
        {"image": "/images/projectImages/EventHorizon2.png", "caption" : "Check in map for an event" },
        {"image": "/images/projectImages/EventHorizon3.png", "caption" : "Event QR code interface" }
      ],
      "techStack":["Java", "Firebase", "Google Maps", "Github", "Figma"],
      "date": "April 2024"
    },
    {
      "id": "FireSafe",
      "title": "FireSafe",
      "cardDescription": "Forest fire software that uses machine learning to locate secluded locations and homes",  
      "paragraphData": [
        {
          "paragraphTitle": "What is FireSafe?",
          "paragraphContent": "FireSafe is an application designed to keep individuals in high risk areas updated on fires. It also ensures that no individual gets left behind in the event of a forest fire eruption. FireSafe uses complex machine learning to locate secluded locations and homes, allowing responders to go down a checklist of locations and ensure individuals are all aware of fire threat and prepared to evacuate."
        },
        {
          "paragraphTitle": "Some Features",
          "paragraphContent": "FireSafe uses machine learning to locate secluded locations and homes. It also ensures that no individual gets left behind in the event of a forest fire eruption. FireSafe uses machine learning to locate secluded locations and homes. It also shows the potential risk of a fire and the radius in which it will potentially reach."
        },
        {
          "paragraphTitle": "Video presentation",
          "paragraphContent": "<a href='https://youtu.be/G8i-fJkVXjM'>Check out our video presentation here</a>"
        }
      ],
      "link": "https://github.com/TylerBeach/FireSafe",
      "imageURL" : "/images/projectImages/FireSafeLogo.png",
      "bannerURL" : "/images/projectImages/FireSafeBanner.png",
      "demoImages": [
        {"image": "/images/projectImages/firesafe-three.png", "caption": "Home Page"},
        {"image": "/images/projectImages/firesafe-two.png", "caption": "Application Page"}
      ],
      "techStack":["Python", "Typescript", "HTML", "CSS", "Tensorflow"],
      "date": "December 2022"
    },
    {
      "id": "FroggyJumper",
      "title": "Froggy Jumper",
      "cardDescription": "2D side scroller game where you play as a frog and jump over snakes to collect flies",  
      "paragraphData": [
        {
          "paragraphTitle": "What is Froggy Jumper?",
          "paragraphContent": "Froggy Jumper is a fast paced side scroller where your objective to survive as long as you can. The game is simple, jump over the snakes and collect the flies. The longer you survive the faster the game gets."
        },
        {
          "paragraphTitle": "Why 'Froggy' Jumper?",
          "paragraphContent": "To put it simple I love frogs! I think they are the coolest animals on the planet. I wanted to make a game that was fun and simple to play. I also wanted to make a game that was challenging and fun to play. I hope you enjoy playing Froggy Jumper as much as I enjoyed making it."
        }
      ],
      "link": "https://github.com/TylerBeach/Froggy-Jumper",
      "imageURL" : "/images/projectImages/FroggyJumperLogo.png",
      "bannerURL" : "/images/projectImages/FroggyJumperBanner.png",
      "demoImages": [
        {"image": "/images/projectImages/FroggyJumperGIF.gif", "caption" : "Gameplay" },
        {"image": "/images/projectImages/FroggyJumperHomeScreen.png", "caption" : "Home screen" }
      ],
      "techStack":["Python", "Pygame"],
      "date": "November 2022"
    },
    {
      "id": "TwitterBackend",
      "title": "Twitter Backend",
      "cardDescription": "Twitter backend clone that allows users to create tweets, follow users, and like tweets using SQL",  
      "paragraphData": [
        {
          "paragraphTitle": "What is it?",
          "paragraphContent": "Twitter Backend is a backend clone of Twitter that allows users to create tweets, follow users, and like tweets. This was a project for CMPUT 291 - File and Database Management at the University of Alberta with a team of four people working together Our group had to design the database schema given the requirements and then implement it to make a functioning backend."},
        {
          "paragraphTitle": "What I learned",
          "paragraphContent": "I learned about developing a database schema for a project and how to implement it to make a functioning backend. I also learned how relational databases work and how to use SQL to interact with the database. This project was a great learning experience and I am excited to continue learning more about databases and backend development throughout my future career in software developement."
        }
      ],
      "link": "https://github.com/TylerBeach/Twitter-Backend-Clone",
      "imageURL" : "/images/Twitter.png",
      "bannerURL" : "/images/projectImages/TwitterCloneBanner.png",
      "demoImages": [
       
      ],
      "techStack":["Python", "SQL"],
      "date": "December 2023"
    }
   
  ],
  "about": {
    "id": "about",
    "firstName": "Tyler",
    "lastName": "Beach",
    "bannerURL": "/images/profileBanner2.jpg",
    "title": "About Me",
    "courseWork": [
      {"CMPUT 174": "Foundations of Computation"},
      {"CMPUT 175": "Foundations of Computation II"},
      {"CMPUT 201":  "Programming Methodology in C"},
      {"CMPUT 204":  "Algorithms and Data Structures"},
      {"CMPUT 206":  "Digital Image Processing"},
      {"CMPUT 229":  "Computer Organization and Architecture"},
      {"CMPUT 267":  "Machine Learning"},
      {"CMPUT 272":  "Formal Systems and Logic"},
      {"CMPUT 291":  "File and Database Management"},
      {"CMPUT 301":  "Software Engineering"},
      {"CMPUT 313":  "Computer Networks"},
      {"CMPUT 365":  "Reinforcement Learning"},
      {"CMPUT 379":  "Operating Systems"},
      {"CMPUT 401":  "Software Engineering II"},
      {"CMPUT 404":  "Web Applications and Architecture"},
      {"CMPUT 415":  "Compiler Design"},
      {"CMPUT 429":  "Computer Organization and Architecture II"},
      {"CMPUT 455": "Search, Knowledge and Simulation"},
      {"CMPUT 461": "Intro to Natural Language Processing"}
    ],
    
    "paragraphs": [
      {
        "title": "Background",
        "image": "/images/Goals.png",
        "paragraphContent": "Tyler Beach is a dedicated and passionate 24-year-old graduate from the University of Alberta with a Bachelor of Science in Computing Science. He enjoyed working with low level programming and computer architecture throughout his studies, which has given him a strong foundation in software development. Tyler is also familiar with web developement and has experience working with various web technologies. He is eager to apply his skills and knowledge in a professional setting and is excited about the opportunities that lie ahead in his career."
      },
      {
        "title": "Education",
        "image": "/images/Education.png",
        "paragraphContent": "Tyler is a graduate of the University of Alberta, where he earned his Bachelor of Science in Computing Science. During his time at the university, Tyler took a variety of courses that helped him develop a strong foundation in computer science and software development."
      },
      {
        "title": "Technologies",
        "image": "/images/Technology.png",
        "paragraphContent": "Tyler has gained experience in a variety of programming languages and technologies throughout his studies and personal projects. He is proficient in languages such as Python, Java, C++, and JavaScript. Tyler has also worked with web technologies such as Next.js, React, and AWS. Additionally, he has experience with databases such as SQL and MongoDB. Tyler is always eager to learn new technologies and is committed to staying up-to-date with the latest developments in the field of software development."
      },
      {
        "title": "Experience",
        "image": "/images/Briefcase.png",
        "paragraphContent": "Tyler has gained valuable experience through various internships and projects. He has worked as a Software Developer Intern at QOL MedTech, a medical technology startup focused on improving the quality of life for patients. During his internship, Tyler contributed to the development of a web application that used wearable technology to monitor patients movements and provide feedback. He designed a backend system using AWS RDS, EC2 and Cognito to manage user data and authentication creating security for patient information. Check out Tyler's projects <a class='underline' href='/projects'>here</a> to see his work and the technologies he has used."
      },
      {
        "title": "The Dream",
        "image": "/images/froggy.jpg",
        "paragraphContent": "Tyler's dream is to work as a software engineer for Microsoft or Spotify. He is passionate about creating innovative software solutions that have a positive impact on people's lives. Tyler is excited about the opportunity to work with cutting-edge technologies and collaborate with talented professionals to develop world-class software products. He is a dedicated and hardworking individual who is committed to continuous learning and personal growth. Tyler is confident that he has the skills and determination to succeed in a competitive industry and is eager to embark on a rewarding career in software development."
      }
    ],
    "link": "/about"
  }
}
